-- https://adventofcode.com/2015/day/25

import Data.List
import System.Environment (getArgs)

assertJust :: Maybe a -> a
assertJust (Just x) = x
assertJust Nothing = error "nothing"

coords :: [(Int, Int)]
coords = go (1, 1)
  where
    go :: (Int, Int) -> [(Int, Int)]
    go (x, 1) = (x, 1) : go (1, x + 1)
    go (x, y) = (x, y) : go (x + 1, y - 1)

-- The voice on the other end of the phone continues with how the codes are actually generated.
-- The first code is 20151125. After that, each code is generated by taking the previous one,
-- multiplying it by 252533, and then keeping the remainder from dividing that value by 33554393.

step :: Int -> Int
step n = (n * 252533) `mod` 33554393

nums :: [Int]
nums = iterate step 20151125

main :: IO ()
main = do
  args <- getArgs
  let row = read @Int $ head args
      col = read @Int $ args !! 1
      idx = assertJust (elemIndex (col, row) coords)
  -- print row
  -- print col
  -- print $ take 10 coords

  print $ nums !! idx
